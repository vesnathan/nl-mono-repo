
AWSTemplateFormatVersion: '2010-09-09'
Description: 'Minimal EC2 Instance - No networking, no security group, just a basic instance.'

Parameters:
  InstanceType:
    Type: String
    Default: t3.micro
    AllowedValues:
      - t3.micro      # $0.0104/hour (~$7.50/month)
      - t3.small      # $0.0208/hour (~$15/month)
      - t3.medium     # $0.0416/hour (~$30/month)
      - t3.large      # $0.0832/hour (~$60/month)
      - t3.xlarge
      - c5.2xlarge
    Description: EC2 instance type (t3.micro recommended for cost optimization)
  
  AutoStopEnabled:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: Enable automatic stop after 2 hours of inactivity
  
  KeyPairName:
    Type: String
    Description: Name of existing EC2 KeyPair to enable SSH access
    Default: "ec2-vsc-key"

  VSCodePort:
    Type: Number
    Default: 8443
    Description: Port for VSCode server (code-server) - HTTPS enabled

Conditions:
  EnableAutoStop: !Equals [!Ref AutoStopEnabled, "true"]

Resources:
  # IAM Role for EC2 instance
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-ec2-role"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Policies:
        - PolicyName: EC2AutoStopPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:StopInstances
                  - ec2:DescribeInstances
                Resource: '*'
                Condition:
                  StringEquals:
                    'ec2:ResourceTag/aws:cloudformation:stack-name': !Ref 'AWS::StackName'
      
  # Instance Profile for the EC2 role
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2Role

  VSCServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH and VSCode server access
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
          Description: SSH access
        - IpProtocol: tcp
          FromPort: !Ref VSCodePort
          ToPort: !Ref VSCodePort
          CidrIp: 0.0.0.0/0
          Description: VSCode server access

  # Launch Template for On-Demand instances
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn: 
      - VSCServerSecurityGroup
      - EC2InstanceProfile
    Properties:
      LaunchTemplateName: !Sub "${AWS::StackName}-launch-template"
      LaunchTemplateData:
        ImageId: !Sub "{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64}}"
        InstanceType: !Ref InstanceType
        KeyName: !Ref KeyPairName
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        SecurityGroupIds:
          - !GetAtt VSCServerSecurityGroup.GroupId
        EbsOptimized: true
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: 8  # Minimum size for cost optimization
              VolumeType: gp3  # More cost-effective than gp2
              DeleteOnTermination: true
              Encrypted: true
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub "${AWS::StackName}-vscode-server"
              - Key: CostOptimized
                Value: "true"
              - Key: AutoStop
                Value: !Ref AutoStopEnabled
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            exec > /var/log/code-server-install.log 2>&1
            
            # Set proper environment variables
            export HOME=/root
            export USER=root
            
            # Wait for cloud-init and other startup processes to complete
            sleep 30
            
            echo "Starting cost-optimized code-server installation..."
            echo "Instance Type: $(curl -s http://169.254.169.254/latest/meta-data/instance-type)"
            echo "Instance Lifecycle: $(curl -s http://169.254.169.254/latest/meta-data/instance-life-cycle)"
            echo "System: $(cat /etc/os-release | grep PRETTY_NAME)"
            
            # Update system packages
            echo "Updating system packages..."
            dnf update -y || yum update -y
            
            # Install curl with conflict resolution and verification
            echo "Installing curl (resolving package conflicts)..."
            dnf install -y curl --allowerasing || yum install -y curl
            
            # Verify curl installation
            if ! command -v curl &> /dev/null; then
              echo "ERROR: curl installation failed"
              exit 1
            fi
            echo "✓ curl installed successfully: $(curl --version | head -1)"
            
            # Install NVM (Node Version Manager) with verification
            echo "Installing NVM..."
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
            
            # Source NVM to make it available in current session
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
            
            # Verify NVM installation
            if ! command -v nvm &> /dev/null; then
              echo "ERROR: NVM installation failed"
              exit 1
            fi
            echo "✓ NVM installed successfully: $(nvm --version)"
            
            # Verify NVM installation
            if ! command -v nvm &> /dev/null; then
              echo "ERROR: NVM installation failed"
              exit 1
            fi
            echo "NVM installed successfully: $(nvm --version)"
            
            # Install latest Node.js via NVM with verification
            echo "Installing Node.js latest via NVM..."
            nvm install node
            nvm use node
            nvm alias default node
            
            # Verify Node.js installation
            if ! command -v node &> /dev/null; then
              echo "ERROR: Node.js installation failed"
              exit 1
            fi
            echo "✓ Node.js installed successfully: $(node --version)"
            
            # Verify npm installation
            if ! command -v npm &> /dev/null; then
              echo "ERROR: npm not available"
              exit 1
            fi
            echo "✓ npm available: $(npm --version)"
            
            # Verify Node.js installation
            if ! command -v node &> /dev/null; then
              echo "ERROR: Node.js installation failed"
              exit 1
            fi
            echo "Node.js installed successfully: $(node --version)"
            
            # Verify npm installation
            if ! command -v npm &> /dev/null; then
              echo "ERROR: npm not available after Node.js installation"
              exit 1
            fi
            echo "npm installed successfully: $(npm --version)"
            
            # Install yarn globally with verification
            echo "Installing yarn..."
            npm install -g yarn
            
            # Verify yarn installation
            if ! command -v yarn &> /dev/null; then
              echo "ERROR: yarn installation failed"
              exit 1
            fi
            echo "✓ yarn installed successfully: $(yarn --version)"
            
            # Set up environment for ec2-user
            echo "Setting up environment for ec2-user..."
            su - ec2-user << 'EOF'
            # Install NVM for ec2-user
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
            
            # Install Node.js for ec2-user
            nvm install node
            nvm use node
            nvm alias default node
            
            # Install Claude CLI for ec2-user (with proper verification)
            echo "Installing Claude CLI..."
            if npm install -g claude-cli 2>/dev/null; then
              echo "✓ Claude CLI installed successfully"
            elif npm install -g @anthropic-ai/cli 2>/dev/null; then
              echo "✓ Anthropic CLI installed successfully"
            else
              echo "⚠ WARNING: Could not install Claude CLI - continuing with deployment"
            fi
            
            # Install yarn globally
            npm install -g yarn
            
            # Add NVM to bashrc
            echo 'export NVM_DIR="$HOME/.nvm"' >> ~/.bashrc
            echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> ~/.bashrc
            echo '[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"' >> ~/.bashrc
            EOF
            
            # Install code-server with proper error handling and verification
            echo "Installing code-server..."
            export HOME=/home/ec2-user
            
            # Try official installation script first
            if curl -fsSL https://code-server.dev/install.sh | sh; then
              echo "✓ code-server installed via official script"
            else
              echo "Official script failed, trying manual RPM installation..."
              
              # Try manual installation as fallback with fixed version
              mkdir -p ~/.cache/code-server
              VERSION="4.101.2"
              DOWNLOAD_URL="https://github.com/coder/code-server/releases/download/v$VERSION/code-server-$VERSION-amd64.rpm"
              
              echo "Downloading code-server v$VERSION from: $DOWNLOAD_URL"
              if curl -fL -o ~/.cache/code-server/code-server.rpm "$DOWNLOAD_URL"; then
                echo "✓ Downloaded code-server RPM"
                if rpm -U ~/.cache/code-server/code-server.rpm; then
                  echo "✓ code-server installed via RPM"
                else
                  echo "ERROR: Failed to install code-server RPM - continuing anyway"
                fi
              else
                echo "ERROR: Failed to download code-server RPM - continuing anyway"
              fi
            fi
            
            # Verify code-server was installed
            if command -v code-server &> /dev/null; then
              echo "✓ code-server installed successfully: $(code-server --version | head -1)"
            else
              echo "⚠ WARNING: code-server command not found - installation may have failed"
              echo "Will attempt to continue with configuration anyway..."
            fi
            
            # Create configuration directory for ec2-user
            echo "Setting up configuration..."
            mkdir -p /home/ec2-user/.config/code-server
            
            # Generate SSL certificate specifically for VS Code server web access
            echo "Generating self-signed SSL certificate for VS Code server..."
            mkdir -p /home/ec2-user/.config/code-server/certs
            
            # Get the public IP for the certificate with retries
            echo "Fetching public IP for SSL certificate..."
            PUBLIC_IP=""
            for i in {1..10}; do
              PUBLIC_IP=$(curl -s --max-time 3 http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null)
              if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "" ]; then
                break
              fi
              echo "Retry $i: Waiting for public IP..."
              sleep 2
            done
            
            # Fallback to localhost if public IP is still not available
            if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "" ]; then
              PUBLIC_IP="localhost"
              echo "Using fallback: localhost for SSL certificate"
            else
              echo "Using IP: $PUBLIC_IP for SSL certificate"
            fi
            
            # Generate SSL certificates for VS Code server (non-blocking with fallbacks)
            echo "Setting up SSL certificates for VS Code server..."
            
            # Generate private key for VS Code server
            echo "Generating SSL private key for VS Code server..."
            if openssl genrsa -out /home/ec2-user/.config/code-server/certs/server.key 2048 2>/dev/null; then
              echo "✓ SSL private key generated successfully"
              
              # Generate self-signed certificate for VS Code server
              echo "Generating SSL certificate for VS Code server..."
              if [ "$PUBLIC_IP" = "localhost" ]; then
                # Simple certificate for localhost only
                if openssl req -new -x509 -key /home/ec2-user/.config/code-server/certs/server.key \
                  -out /home/ec2-user/.config/code-server/certs/server.crt \
                  -days 365 -subj "/C=US/ST=AWS/L=Cloud/O=VSCode/CN=localhost" 2>/dev/null; then
                  echo "✓ SSL certificate generated successfully for VS Code server (localhost only)"
                  SSL_ENABLED=true
                else
                  echo "⚠ Failed to generate SSL certificate for localhost"
                  SSL_ENABLED=false
                fi
              else
                # Certificate with both IP and DNS names
                if openssl req -new -x509 -key /home/ec2-user/.config/code-server/certs/server.key \
                  -out /home/ec2-user/.config/code-server/certs/server.crt \
                  -days 365 -subj "/C=US/ST=AWS/L=Cloud/O=VSCode/CN=$PUBLIC_IP" \
                  -addext "subjectAltName=IP:$PUBLIC_IP,DNS:localhost" 2>/dev/null; then
                  echo "✓ SSL certificate generated successfully for VS Code server (IP: $PUBLIC_IP)"
                  SSL_ENABLED=true
                else
                  echo "⚠ Failed to generate SSL certificate with IP, trying localhost fallback..."
                  if openssl req -new -x509 -key /home/ec2-user/.config/code-server/certs/server.key \
                    -out /home/ec2-user/.config/code-server/certs/server.crt \
                    -days 365 -subj "/C=US/ST=AWS/L=Cloud/O=VSCode/CN=localhost" 2>/dev/null; then
                    echo "✓ SSL certificate generated successfully for VS Code server (localhost fallback)"
                    SSL_ENABLED=true
                  else
                    echo "⚠ Failed to generate SSL certificate, will use HTTP fallback"
                    SSL_ENABLED=false
                  fi
                fi
              fi
              
              if [ "$SSL_ENABLED" = true ]; then
                # Set proper permissions
                chmod 600 /home/ec2-user/.config/code-server/certs/server.key
                chmod 644 /home/ec2-user/.config/code-server/certs/server.crt
                echo "✓ SSL certificates ready"
              fi
            else
              echo "⚠ Failed to generate SSL private key, will use HTTP fallback"
              SSL_ENABLED=false
            fi
            
            # Create configuration file with dynamic SSL/HTTP based on certificate availability
            echo "Creating code-server configuration..."
            if [ "$SSL_ENABLED" = true ]; then
              echo "Configuring code-server with HTTPS on port ${VSCodePort}"
              cat > /home/ec2-user/.config/code-server/config.yaml << 'CONFIG_EOF'
            bind-addr: 0.0.0.0:${VSCodePort}
            auth: password
            password: vscodepassword
            cert: /home/ec2-user/.config/code-server/certs/server.crt
            cert-key: /home/ec2-user/.config/code-server/certs/server.key
            CONFIG_EOF
            else
              echo "Configuring code-server with HTTP on port 8080 (SSL fallback)"
              cat > /home/ec2-user/.config/code-server/config.yaml << 'CONFIG_EOF'
            bind-addr: 0.0.0.0:8080
            auth: password
            password: vscodepassword
            CONFIG_EOF
            fi
            
            # Set proper ownership
            chown -R ec2-user:ec2-user /home/ec2-user/.config
            
            # Network optimizations for poor internet connections
            echo "Applying network optimizations for connection stability..."
            
            # Increase TCP keepalive settings for better connection stability
            echo 'net.ipv4.tcp_keepalive_time = 600' >> /etc/sysctl.conf
            echo 'net.ipv4.tcp_keepalive_intvl = 60' >> /etc/sysctl.conf
            echo 'net.ipv4.tcp_keepalive_probes = 6' >> /etc/sysctl.conf
            
            # Apply sysctl changes
            sysctl -p
            
            echo "Starting code-server service..."
            # Start and enable the service
            systemctl enable --now code-server@ec2-user
            
            # Wait a moment and check if service started successfully
            echo "Waiting for code-server service to start..."
            sleep 10
            
            # Check service status multiple times
            for i in {1..5}; do
              if systemctl is-active --quiet code-server@ec2-user; then
                echo "SUCCESS: code-server service started successfully on attempt $i"
                break
              else
                echo "Attempt $i: code-server service not yet active, waiting..."
                sleep 5
              fi
              
              if [ $i -eq 5 ]; then
                echo "ERROR: code-server service failed to start after 5 attempts"
                echo "Service status:"
                systemctl status code-server@ec2-user --no-pager
                echo "Service logs:"
                journalctl -u code-server@ec2-user --no-pager -n 20
                exit 1
              fi
            done
            
            # Display service status
            echo "Service status:"
            systemctl status code-server@ec2-user --no-pager
            
            # Test connectivity
            PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
            echo "Testing local connectivity to code-server..."
            for i in {1..3}; do
              if curl -k -s -o /dev/null -w "%{http_code}" https://localhost:${VSCodePort} | grep -q "200\|302\|401"; then
                echo "SUCCESS: code-server is responding locally on port ${VSCodePort}"
                break
              else
                echo "Attempt $i: code-server not responding locally, waiting..."
                sleep 5
              fi
              
              if [ $i -eq 3 ]; then
                echo "WARNING: code-server may not be fully ready yet"
              fi
            done
            
            echo "code-server is accessible at: https://$PUBLIC_IP:${VSCodePort}"
            echo "⚠️  HTTPS uses a self-signed certificate - you'll need to accept the browser security warning"
              echo "Password: vscodepassword"
            else
              echo "ERROR: code-server service failed to start"
              echo "Service status:"
              systemctl status code-server@ec2-user --no-pager
              echo "Service logs:"
              journalctl -u code-server@ec2-user --no-pager -n 20
              exit 1
            fi
            
            # Add auto-stop functionality if enabled
            if [ "${AutoStopEnabled}" = "true" ]; then
              echo "Setting up auto-stop after 2 hours of inactivity..."
              
              # Create auto-stop script
              cat > /home/ec2-user/auto-stop.sh << 'EOFSTOP'
            #!/bin/bash
            # Auto-stop instance after 2 hours of no VSCode connections
            
            LOG_FILE="/var/log/auto-stop.log"
            INACTIVE_TIME=7200  # 2 hours in seconds
            
            echo "$(date): Checking for VSCode activity..." >> $LOG_FILE
            
            # Check if anyone is connected to VSCode (HTTPS on port 8443)
            if netstat -tn | grep -E ":8443.*ESTABLISHED"; then
              echo "$(date): Active connections found, resetting timer" >> $LOG_FILE
              exit 0
            fi
            
            # Check system load
            LOAD=$(uptime | awk '{print $10}' | cut -d',' -f1)
            if (( $(echo "$LOAD > 0.1" | bc -l) )); then
              echo "$(date): System load $LOAD > 0.1, keeping instance running" >> $LOG_FILE
              exit 0
            fi
            
            # If no activity for 2 hours, stop instance
            LAST_ACTIVITY=$(stat -c %Y /var/log/code-server-install.log 2>/dev/null || echo 0)
            CURRENT_TIME=$(date +%s)
            INACTIVE_DURATION=$((CURRENT_TIME - LAST_ACTIVITY))
            
            if [ $INACTIVE_DURATION -gt $INACTIVE_TIME ]; then
              echo "$(date): No activity for $INACTIVE_DURATION seconds, stopping instance" >> $LOG_FILE
              INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
              REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)
              echo "$(date): Stopping instance $INSTANCE_ID in region $REGION" >> $LOG_FILE
              aws ec2 stop-instances --instance-ids $INSTANCE_ID --region $REGION >> $LOG_FILE 2>&1 || echo "$(date): Failed to stop instance" >> $LOG_FILE
            else
              echo "$(date): Last activity $INACTIVE_DURATION seconds ago, continuing" >> $LOG_FILE
            fi
            EOFSTOP
              
              chmod +x /home/ec2-user/auto-stop.sh
              chown ec2-user:ec2-user /home/ec2-user/auto-stop.sh
              
              # Add cron job to run every 30 minutes
              echo "*/30 * * * * /home/ec2-user/auto-stop.sh" | crontab -u ec2-user -
              echo "Auto-stop configured: instance will stop after 2 hours of inactivity"
            fi
            
            echo "Installation completed successfully"

  # Actual EC2 Instance using Launch Template
  BasicInstance:
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber

Outputs:
  InstanceId:
    Description: EC2 Instance ID
    Value: !Ref BasicInstance
  PublicIP:
    Description: Public IP address of the instance
    Value: !GetAtt BasicInstance.PublicIp
  VSCodeURL:
    Description: VSCode server URL (HTTPS with self-signed certificate)
    Value: !Sub "https://${BasicInstance.PublicIp}:${VSCodePort}"
  SecurityInfo:
    Description: Security information for HTTPS access
    Value: "⚠️ HTTPS uses self-signed certificate - accept browser security warning"
  SSHCommand:
    Description: SSH command to connect to the instance
    Value: !Sub "ssh -i ${KeyPairName}.pem ec2-user@${BasicInstance.PublicIp}"
  IAMRole:
    Description: IAM role assigned to the instance
    Value: !Ref EC2Role
  CostOptimizations:
    Description: Cost optimization features enabled
    Value: !Sub "Instance: ${InstanceType} | Auto-Stop: ${AutoStopEnabled}"
