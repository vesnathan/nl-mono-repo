// Auto-generated by ResolverCompiler. Source: /workspaces/nl-mono-repo/packages/cloudwatchlive/backend/resources/AppSync/resolvers/users/Queries/Query.getCWLUser.ts - 2025-06-10T03:22:06.230Z
// Original S3 Key: resolvers/dev/users/Queries/Query.getCWLUser.js

import { util, runtime, } from "@aws-appsync/utils";
import { ClientType, } from "../../gqlTypes";
export function request(ctx) {
    const { userId } = ctx.args;
    if (!userId) {
        runtime.earlyReturn(undefined);
    }
    const identity = ctx.identity;
    if (identity.username !== userId) {
        return util.error("User is not allowed to retrieve data of a different user", "Unauthorized");
    }
    console.log(`Getting user data for userId: ${userId}`);
    console.log(`Identity username: ${identity.username}`);
    // For JavaScript resolvers, we return the arguments to be processed in the response function
    return {
        operation: "GetItem",
        key: util.dynamodb.toMapValues({ userId }),
    };
}
export function response(ctx) {
    console.log("Response result:", JSON.stringify(ctx.result));
    if (ctx.error) {
        console.error("Error in resolver:", ctx.error);
        util.error(ctx.error.message, ctx.error.type);
    }
    const identity = ctx.identity;
    const { userId } = ctx.args;
    // If no user found in DynamoDB, we need to handle this properly
    // since the schema requires a non-nullable CWLUser return type
    if (!ctx.result) {
        // Log the issue for debugging
        console.error(`User not found in DynamoDB for userId: ${userId}`);
        console.error(`Identity username: ${identity.username}`);
        console.error(`Identity groups: ${JSON.stringify(identity.groups)}`);
        // Return an error instead of null to satisfy GraphQL schema requirements
        util.error(`User profile not found. Please contact support if this issue persists. UserId: ${userId}`, "UserNotFound");
    }
    const user = ctx.result;
    // Map Cognito groups to ClientType
    const cognitoGroups = identity.groups || [];
    console.log(`Cognito groups for user ${userId}:`, JSON.stringify(cognitoGroups));
    const clientType = [];
    // Map Cognito group names to ClientType enum values
    for (const group of cognitoGroups) {
        switch (group) {
            case 'SuperAdmin':
                clientType.push(ClientType.SuperAdmin);
                break;
            case 'EventCompanyAdmin':
                clientType.push(ClientType.EventCompanyAdmin);
                break;
            case 'EventCompanyStaff':
                clientType.push(ClientType.EventCompanyStaff);
                break;
            case 'TechCompanyAdmin':
                clientType.push(ClientType.TechCompanyAdmin);
                break;
            case 'TechCompanyStaff':
                clientType.push(ClientType.TechCompanyStaff);
                break;
            case 'RegisteredAttendee':
                clientType.push(ClientType.RegisteredAtendee);
                break;
            case 'UnregisteredAttendee':
                clientType.push(ClientType.UnregisteredAttendee);
                break;
            default:
                console.log(`Unknown group: ${group}, not mapping to any ClientType`);
        }
    }
    // If no client types were mapped from groups, use a default type to prevent GraphQL error
    // Since the schema requires at least one value in the clientType array
    if (clientType.length === 0) {
        console.log(`No groups mapped to ClientType, adding default UnregisteredAttendee`);
        clientType.push(ClientType.UnregisteredAttendee); // Default to UnregisteredAttendee if no groups found
    }
    console.log(`Final clientType array:`, JSON.stringify(clientType));
    // Ensure all required non-nullable fields have values
    const userRole = user.userRole || "User";
    const userEmail = user.userEmail || identity.username || "";
    const userFirstName = user.userFirstName || "";
    const userLastName = user.userLastName || "";
    const userPhone = user.userPhone || "";
    const userTitle = user.userTitle || "";
    const organizationId = user.organizationId || "";
    const userAddedById = user.userAddedById || "";
    const userCreated = user.userCreated || new Date().toISOString();
    // Return the complete user object with all required fields populated
    return {
        userId: userId,
        userEmail: userEmail,
        userFirstName: userFirstName,
        userLastName: userLastName,
        userPhone: userPhone,
        userTitle: userTitle,
        userRole: userRole,
        organizationId: organizationId,
        userAddedById: userAddedById,
        userCreated: userCreated,
        privacyPolicy: user.privacyPolicy || false,
        termsAndConditions: user.termsAndConditions || false,
        clientType: clientType,
    };
}
